"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const apollo_server_express_1 = require("apollo-server-express");
const apollo_server_hapi_1 = require("apollo-server-hapi");
const apollo_server_koa_1 = require("apollo-server-koa");
const apollo_server_micro_1 = require("apollo-server-micro");
const bodyParser = require("body-parser");
const connect = require("connect");
const express = require("express");
const hapi = require("hapi");
const http = require("http");
const koa = require("koa");
const koaBodyparser = require("koa-bodyparser");
const koaRouter = require("koa-router");
const micro_1 = require("micro");
const microRouter = require("microrouter");
const qs = require("qs");
const urlModule = require("url");
const schema_1 = require("./schema");
const util_1 = require("./util");
const engine_common_1 = require("./engine-common");
const engine_1 = require("../engine");
engine_common_1.runSuitesForHttpServerFramework('express', {
    createApp() {
        const path = '/graphql';
        const app = express();
        app.get(`${path}/ping`, (req, res) => {
            res.json({ pong: true });
        });
        app.use(path, bodyParser.json(), apollo_server_express_1.graphqlExpress({
            schema: schema_1.schema,
            rootValue: schema_1.rootValue,
            tracing: true,
            cacheControl: true,
        }));
        return app;
    },
    serverForApp(app) {
        return http.createServer(app);
    },
    appParameter: 'expressApp',
});
function connectQuery(req, res, next) {
    const parsedUrl = urlModule.parse(req.url);
    req.query = qs.parse(parsedUrl.query);
    next();
}
engine_common_1.runSuitesForHttpServerFramework('connect', {
    createApp() {
        const path = '/graphql';
        const app = connect().use(connectQuery);
        app.use(`${path}/ping`, (req, res) => {
            res.end(JSON.stringify({ pong: true }));
        });
        app.use(path, bodyParser.json());
        app.use(path, apollo_server_express_1.graphqlConnect({
            schema: schema_1.schema,
            rootValue: schema_1.rootValue,
            tracing: true,
            cacheControl: true,
        }));
        return app;
    },
    serverForApp(app) {
        return http.createServer(app);
    },
    appParameter: 'connectApp',
});
engine_common_1.runSuitesForHttpServerFramework('koa', {
    createApp() {
        const app = new koa();
        const path = '/graphql';
        const graphqlHandler = apollo_server_koa_1.graphqlKoa({
            schema: schema_1.schema,
            rootValue: schema_1.rootValue,
            tracing: true,
            cacheControl: true,
        });
        const router = new koaRouter();
        router.post('/graphql', koaBodyparser(), graphqlHandler);
        router.get('/graphql', graphqlHandler);
        router.get('/graphql/ping', (ctx) => __awaiter(this, void 0, void 0, function* () {
            ctx.body = JSON.stringify({ pong: true });
        }));
        app.use(router.routes());
        app.use(router.allowedMethods());
        return app;
    },
    serverForApp(app) {
        return http.createServer(app.callback());
    },
    appParameter: 'koaApp',
});
engine_common_1.runSuitesForHttpServerFramework('micro', {
    createApp() {
        const handler = apollo_server_micro_1.microGraphql({
            schema: schema_1.schema,
            rootValue: schema_1.rootValue,
            tracing: true,
            cacheControl: true,
        });
        return micro_1.default(microRouter.router(microRouter.get('/graphql/ping', () => {
            return JSON.stringify({ pong: true });
        }), microRouter.get('/graphql', handler), microRouter.get('/graphql/', handler), microRouter.post('/graphql', handler), microRouter.post('/graphql/', handler)));
    },
    serverForApp(app) {
        return app;
    },
    appParameter: 'httpServer',
});
// hapi requires its own API since it doesn't directly give you an http.Server.
describe('hapi integration', () => {
    let server;
    let engine;
    beforeEach(() => {
        engine = null;
    });
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (engine) {
            yield engine.stop();
        }
        yield server.stop();
    }));
    function gqlServer(options) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new hapi.Server(Object.assign({}, options, { router: {
                    stripTrailingSlash: true,
                } }));
            server.route({
                path: '/graphql/ping',
                method: 'GET',
                handler: () => {
                    return JSON.stringify({ pong: true });
                },
            });
            yield server.register({
                plugin: apollo_server_hapi_1.graphqlHapi,
                options: {
                    path: '/graphql',
                    graphqlOptions: {
                        schema: schema_1.schema,
                        rootValue: schema_1.rootValue,
                        tracing: true,
                        cacheControl: true,
                    },
                    route: {
                        cors: true,
                    },
                },
            });
        });
    }
    describe('without engine', () => {
        engine_common_1.runSuite(() => __awaiter(this, void 0, void 0, function* () {
            yield gqlServer({ host: 'localhost', port: 0 });
            yield server.start();
            return `http://localhost:${server.info.port}/graphql`;
        }), true, 'hapi');
    });
    describe('with engine', () => {
        engine_common_1.runSuite(() => __awaiter(this, void 0, void 0, function* () {
            engine = new engine_1.ApolloEngine({
                apiKey: 'faked',
                logging: {
                    level: 'WARN',
                    destination: 'STDERR',
                },
                reporting: {
                    disabled: true,
                },
                frontends: [
                    {
                        extensions: {
                            strip: ['tracing'],
                        },
                    },
                ],
            });
            const hapiListener = yield engine.hapiListener({
                // Let engineproxy get an ephemeral port; we'll learn about it in the
                // listening callback.
                port: 0,
            });
            yield gqlServer({ autoListen: false, listener: hapiListener });
            yield server.start();
            return `${engine.engineListeningAddress.url}/graphql`;
        }), false, 'hapi');
    });
});
test('can pass a string as a port', () => __awaiter(this, void 0, void 0, function* () {
    const httpServer = http.createServer();
    const engine = new engine_1.ApolloEngine({
        apiKey: 'faked',
        logging: {
            level: 'WARN',
            destination: 'STDERR',
        },
        reporting: {
            disabled: true,
        },
    });
    try {
        const p = new Promise(resolve => engine.listen({ port: '0', httpServer }, resolve));
        yield p;
    }
    finally {
        yield engine.stop();
        httpServer.close();
    }
}));
test('must specify apiKey', () => __awaiter(this, void 0, void 0, function* () {
    const httpServer = http.createServer();
    const engine = new engine_1.ApolloEngine();
    const p = new Promise((resolve, reject) => {
        engine.on('error', e => resolve(e));
        engine.listen({
            port: '0',
            httpServer,
            launcherOptions: { proxyStderrStream: util_1.devNull() },
        }, () => reject(new Error('should not start')));
    });
    yield p;
    httpServer.close();
}));
describe('env var', () => {
    let oldValue;
    beforeEach(() => {
        oldValue = process.env.ENGINE_API_KEY;
    });
    afterEach(() => {
        if (oldValue === undefined) {
            delete process.env.ENGINE_API_KEY;
        }
        else {
            process.env.ENGINE_API_KEY = oldValue;
        }
    });
    test('can specify apiKey as env var', () => __awaiter(this, void 0, void 0, function* () {
        const httpServer = http.createServer();
        const engine = new engine_1.ApolloEngine();
        process.env.ENGINE_API_KEY = 'faked';
        try {
            const p = new Promise(resolve => engine.listen({
                port: '0',
                httpServer,
                launcherOptions: { proxyStderrStream: util_1.devNull() },
            }, resolve));
            yield p;
        }
        finally {
            yield engine.stop();
            httpServer.close();
        }
    }));
});
describe('launch failure', () => {
    let engine = null;
    let httpServer = null;
    beforeEach(() => {
        engine = null;
        httpServer = null;
    });
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (engine !== null) {
            const child = engine['launcher']['child'];
            if (child) {
                yield engine.stop();
                expect(util_1.processIsRunning(child.pid)).toBe(false);
            }
            engine = null;
        }
        if (httpServer) {
            httpServer.close();
        }
    }));
    test('emits error on invalid config', () => __awaiter(this, void 0, void 0, function* () {
        engine = new engine_1.ApolloEngine({
            apiKey: 'faked',
            logging: {
                level: 'INVALID',
            },
            reporting: {
                disabled: true,
            },
        });
        const start = +new Date();
        httpServer = http.createServer();
        const p = new Promise((resolve, reject) => {
            // Help TS understand that these variables are still set.
            httpServer = httpServer;
            engine = engine;
            // We expect to get an error, so that's why we're *resolving* with it.
            engine.once('error', err => {
                resolve(err.message);
            });
            engine.listen({
                httpServer,
                port: 0,
                launcherOptions: { proxyStderrStream: util_1.devNull() },
            }, () => reject(new Error('Engine should not listen successfully')));
        });
        yield expect(p).resolves.toMatch(/Engine crashed due to invalid configuration/);
        const end = +new Date();
        expect(end - start).toBeLessThan(5000);
    }));
});
engine_common_1.runCleanupTests(false);
//# sourceMappingURL=engine.test.js.map