"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
const path_1 = require("path");
const child_process_1 = require("child_process");
const sinon_1 = require("sinon");
const schema_1 = require("./schema");
const engine_1 = require("../engine");
const acceptableEndings = ['/', '?', '?123', '/?123'];
function runSuite(before, hasTracing, frameworkName) {
    let url;
    // micro has an unconfigurable behavior to console.error any error thrown by a
    // handler (https://github.com/zeit/micro/issues/329).  We use sinon to
    // override console.error; however, we use callThrough to ensure that by
    // default, it just calls console.error normally. The tests that throw errors
    // tell the stub to "stub out" console.error on the first call.
    let consoleErrorStub;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        consoleErrorStub = sinon_1.stub(console, 'error');
        consoleErrorStub.callThrough();
        url = yield before();
    }));
    afterEach(() => {
        consoleErrorStub.restore();
    });
    test('processes successful query', () => {
        return schema_1.verifyEndpointSuccess(url, hasTracing);
    });
    acceptableEndings.forEach(acceptableEnding => {
        test(`using server endpoint ${acceptableEnding}`, () => {
            return schema_1.verifyEndpointSuccess(url + acceptableEnding, hasTracing);
        });
    });
    test('processes successful GET query', () => {
        return schema_1.verifyEndpointGet(url, hasTracing);
    });
    test('processes invalid query', () => {
        if (frameworkName === 'micro') {
            consoleErrorStub.onFirstCall().returns(undefined);
        }
        return schema_1.verifyEndpointFailure(url);
    });
    test('processes query that errors', () => {
        return schema_1.verifyEndpointError(url);
    });
    test('processes batched queries', () => {
        return schema_1.verifyEndpointBatch(url, hasTracing);
    });
    test('returns cache information', () => __awaiter(this, void 0, void 0, function* () {
        const body = yield schema_1.verifyEndpointSuccess(url, hasTracing);
        expect(body['extensions'] && body['extensions']['cacheControl']).toBeDefined();
    }));
    test('http proxying works', done => {
        const childUrl = `${url}/ping`;
        request(childUrl, (err, response, body) => {
            expect(err).toBe(null);
            expect(body).toBe('{"pong":true}');
            done();
        });
    });
}
exports.runSuite = runSuite;
function runSuitesForHttpServerFramework(frameworkName, { createApp, serverForApp, appParameter }) {
    describe(`${frameworkName} integration`, () => {
        let httpServers = [];
        let engine;
        beforeEach(() => {
            engine = null;
            httpServers = [];
        });
        afterEach(() => __awaiter(this, void 0, void 0, function* () {
            if (engine) {
                yield engine.stop();
            }
            httpServers.forEach(server => server.close());
        }));
        function gqlServer() {
            const app = createApp();
            const server = serverForApp(app);
            httpServers.push(server);
            return server.listen().address().port;
        }
        describe('without engine', () => {
            runSuite(() => __awaiter(this, void 0, void 0, function* () {
                return `http://localhost:${gqlServer()}/graphql`;
            }), true, frameworkName);
        });
        describe('with engine', () => {
            runSuite(() => __awaiter(this, void 0, void 0, function* () {
                const app = createApp();
                engine = new engine_1.ApolloEngine({
                    apiKey: 'faked',
                    logging: {
                        level: 'WARN',
                        destination: 'STDERR',
                    },
                    reporting: {
                        disabled: true,
                    },
                    frontends: [
                        {
                            extensions: {
                                strip: ['tracing'],
                            },
                        },
                    ],
                });
                const p = new Promise(resolve => {
                    engine.listen({
                        // Let engineproxy get an ephemeral port; we'll learn about it in the
                        // listening callback.
                        port: 0,
                        [appParameter]: app,
                        launcherOptions: {
                            extraEnv: {
                                // engineproxy should only try to connect to our origin
                                // (reporting is diabled), which is on localhost, so this
                                // bad proxy should be ignored. This is a regression test
                                // from back when we would put unspecified IPs in the origin
                                // URL by default (instead of listening on 127.0.0.1 by
                                // default) and the Go http library would try to use the
                                // proxy (https://github.com/golang/go/issues/24737).
                                HTTP_PROXY: 'http://bad.proxy.example.com/',
                            },
                        },
                    }, () => {
                        resolve(`${engine.engineListeningAddress.url}/graphql`);
                    });
                });
                return yield p;
            }), false, frameworkName);
        });
    });
}
exports.runSuitesForHttpServerFramework = runSuitesForHttpServerFramework;
function runCleanupTests(forLauncher) {
    describe('engineproxy cleaned up', () => {
        ['SIGINT', 'SIGTERM', 'SIGUSR2', 'uncaughtException', 'exit'].forEach(event => {
            test(`on ${event}`, () => __awaiter(this, void 0, void 0, function* () {
                // There is no SIGUSR2 on Windows.
                if (event === 'SIGUSR2' && process.platform === 'win32') {
                    return;
                }
                const env = Object.assign({}, process.env);
                if (forLauncher) {
                    env.AEJ_TEST_LAUNCHER = 't';
                }
                if (event === 'uncaughtException') {
                    env.AEJ_TEST_UNCAUGHT_EXCEPTION = 't';
                }
                if (event === 'exit') {
                    env.AEJ_TEST_PROCESS_EXIT = 't';
                }
                const child = child_process_1.fork(path_1.join(__dirname, 'child.js'), [], {
                    env,
                    // You may want to remove the following line to debug failures in
                    // these tests.
                    silent: true,
                });
                const proxyPid = yield new Promise(resolve => {
                    child.on('message', m => {
                        resolve(m.pid);
                    });
                });
                // Verify that the proxy exists.
                process.kill(proxyPid, 0);
                const childDone = new Promise(resolve => {
                    child.on('exit', resolve);
                });
                if (event.startsWith('SIG')) {
                    child.kill(event);
                }
                yield childDone;
                // 'exit' and 'uncaughtException' don't actually wait for the proxy to
                // be gone, so sleep a bit to avoid races in tests.
                if (event === 'exit' || event === 'uncaughtException') {
                    yield new Promise(resolve => setTimeout(resolve, 10));
                }
                // Verify that the proxy is gone.
                expect(() => process.kill(proxyPid, 0)).toThrow();
            }));
        });
    });
}
exports.runCleanupTests = runCleanupTests;
//# sourceMappingURL=engine-common.js.map