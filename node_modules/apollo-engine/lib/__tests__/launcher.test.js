"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const express = require("express");
const tmp = require("tmp");
const bodyParser = require("body-parser");
const apollo_server_express_1 = require("apollo-server-express");
const fs_1 = require("fs");
const stream_1 = require("stream");
const schema_1 = require("./schema");
const util_1 = require("./util");
const engine_common_1 = require("./engine-common");
const launcher_1 = require("../launcher");
function basicConfig(port) {
    return {
        apiKey: 'faked',
        logging: {
            level: 'WARN',
            destination: 'STDERR',
        },
        frontends: [
            {
                // We need to know which to connect to.
                host: '127.0.0.1',
            },
        ],
        reporting: {
            disabled: true,
        },
        origins: [
            {
                http: {
                    url: `http://127.0.0.1:${port}/graphql`,
                },
            },
        ],
    };
}
describe('ApolloEngineLauncher', () => {
    let httpServers = [];
    let port;
    let config;
    let launcher = null;
    beforeEach(() => {
        httpServers = [];
        port = gqlServer();
        config = basicConfig(port);
    });
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (launcher !== null) {
            const child = launcher['child'];
            if (child !== null) {
                yield launcher.stop();
                expect(util_1.processIsRunning(child.pid)).toBe(false);
            }
            launcher = null;
        }
        httpServers.forEach(server => server.close());
    }));
    function gqlServer(path = '/graphql') {
        const app = express();
        app.use(path, bodyParser.json(), apollo_server_express_1.graphqlExpress({
            schema: schema_1.schema,
            rootValue: schema_1.rootValue,
            tracing: true,
        }));
        const server = http.createServer(app);
        httpServers.push(server);
        return server.listen().address().port;
    }
    describe('config', () => {
        test('allows reading and reloading config from file', () => __awaiter(this, void 0, void 0, function* () {
            // Make a temp filename for the config we're going to reload, and for a
            // log file we're going to eventually look for.
            const tmpConfig = tmp.fileSync({ discardDescriptor: true });
            const tmpLog = tmp.fileSync({ discardDescriptor: true });
            fs_1.unlinkSync(tmpLog.name);
            // Write a basic config file out to disk. It does not have request logging
            // turned on.
            fs_1.writeFileSync(tmpConfig.name, JSON.stringify(config));
            // Run Engine. Ask it to check the config file for reloads every 5ms
            // instead of the default 5s, for a faster test.
            launcher = new launcher_1.ApolloEngineLauncher(tmpConfig.name);
            // Make sure it runs properly.
            const listeningAddress = yield launcher.start({
                extraArgs: ['-config-reload-file=5ms'],
            });
            yield schema_1.verifyEndpointSuccess(`${listeningAddress.url}/graphql`, false);
            // Add request logging to the config file. Write it out (atomically!) and
            // wait twice the -config-reload-file amount of time.
            config.logging.request = {
                destination: tmpLog.name,
            };
            fs_1.writeFileSync(tmpConfig.name + '.atomic', JSON.stringify(config));
            fs_1.renameSync(tmpConfig.name + '.atomic', tmpConfig.name);
            yield new Promise(resolve => setTimeout(resolve, 10));
            // Make a request, which should be logged.
            yield schema_1.verifyEndpointSuccess(`${listeningAddress.url}/graphql`, false);
            // Wait a moment and verify the request log exists.
            yield new Promise(resolve => setTimeout(resolve, 10));
            fs_1.readFileSync(tmpLog.name);
        }));
        test('allows reading config from argument', () => __awaiter(this, void 0, void 0, function* () {
            launcher = new launcher_1.ApolloEngineLauncher(config);
            // Make sure it runs properly.
            const listeningAddress = yield launcher.start();
            yield schema_1.verifyEndpointSuccess(`${listeningAddress.url}/graphql`, false);
        }));
    });
    describe('stdio redirection', () => {
        test('custom stdout', () => __awaiter(this, void 0, void 0, function* () {
            config.logging.level = 'INFO';
            config.logging.destination = 'STDOUT';
            launcher = new launcher_1.ApolloEngineLauncher(config);
            let written = false;
            const proxyStdoutStream = new stream_1.Writable({
                write(chunk, encoding, callback) {
                    written = true;
                    callback();
                },
            });
            yield launcher.start({ proxyStdoutStream });
            expect(written).toBe(true);
        }));
        test('custom stderr', () => __awaiter(this, void 0, void 0, function* () {
            config.logging.level = 'INFO';
            launcher = new launcher_1.ApolloEngineLauncher(config);
            let written = false;
            const proxyStderrStream = new stream_1.Writable({
                write(chunk, encoding, callback) {
                    written = true;
                },
            });
            yield launcher.start({ proxyStderrStream });
            expect(written).toBe(true);
        }));
    });
    describe('process management', () => {
        test('restarts binary', () => __awaiter(this, void 0, void 0, function* () {
            launcher = new launcher_1.ApolloEngineLauncher(config);
            const listenAddress = yield launcher.start();
            yield schema_1.verifyEndpointSuccess(`${listenAddress.url}/graphql`, false);
            const child = launcher['child'];
            expect(child).toBeDefined();
            const childPid = child.pid;
            expect(util_1.processIsRunning(childPid)).toBe(true);
            // Directly kill process, wait for notice another process has started:
            const restartingPromise = new Promise(resolve => {
                launcher.once('restarting', resolve);
            });
            const restartPromise = new Promise(resolve => {
                launcher.once('start', resolve);
            });
            child.kill('SIGKILL');
            yield restartingPromise;
            yield restartPromise;
            const child2 = launcher['child'];
            expect(child2).toBeDefined();
            const restartedPid = child2.pid;
            expect(restartedPid).not.toBe(child);
            expect(util_1.processIsRunning(childPid)).toBe(false);
            expect(util_1.processIsRunning(restartedPid)).toBe(true);
        }));
        test('exits faster than timeout on invalid config', () => __awaiter(this, void 0, void 0, function* () {
            config.logging.level = 'invalid-level';
            launcher = new launcher_1.ApolloEngineLauncher(config);
            const start = +new Date();
            yield expect(launcher.start({ proxyStderrStream: util_1.devNull() })).rejects.toThrow(/Engine crashed due to invalid configuration/);
            const end = +new Date();
            expect(end - start).toBeLessThan(5000);
        }));
        test('hits timeout on problems other than invalid config', () => __awaiter(this, void 0, void 0, function* () {
            launcher = new launcher_1.ApolloEngineLauncher(config);
            const start = +new Date();
            let restarted = 0;
            launcher.on('restarting', () => {
                restarted++;
            });
            const p = launcher.start({
                proxyStdoutStream: util_1.devNull(),
                startupTimeout: 300,
                // This is a kind of silly way to get it to "fail" with a non-bad-config
                // reason, but hey, it works.
                extraArgs: ['-version'],
            });
            yield expect(p).rejects.toThrow(/engineproxy timed out/);
            const end = +new Date();
            expect(end - start).toBeGreaterThanOrEqual(300);
            expect(restarted).toBeGreaterThan(0);
        }));
        engine_common_1.runCleanupTests(true);
    });
});
//# sourceMappingURL=launcher.test.js.map